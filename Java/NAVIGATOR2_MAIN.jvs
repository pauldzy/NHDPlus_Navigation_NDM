SET DEFINE OFF
CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED nhdplus_navigation2."navigator2_main"
AUTHID CURRENT_USER
AS 

import java.util.Map;
import java.util.HashMap;
import oracle.sql.ARRAY;
import oracle.sql.CHAR;
import oracle.sql.NUMBER;
import java.sql.Connection;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import oracle.jdbc.OraclePreparedStatement;
import oracle.jdbc.OracleDriver;
///////
import oracle.spatial.network.lod.CategorizedUserData;
import oracle.spatial.network.lod.DefaultLinkCostCalculator;
import oracle.spatial.network.lod.DefaultNodeCostCalculator;
import oracle.spatial.network.lod.LinkCostCalculator;
import oracle.spatial.network.lod.LODAnalysisInfo;
import oracle.spatial.network.lod.LODNetworkConstraint;
import oracle.spatial.network.lod.LODNetworkManager;
import oracle.spatial.network.lod.LogicalLightPath;
import oracle.spatial.network.lod.LogicalLightSubPath;
import oracle.spatial.network.lod.LogicalLink;
import oracle.spatial.network.lod.LogicalNetLink;
import oracle.spatial.network.lod.LogicalNetNode;
import oracle.spatial.network.lod.LogicalNode;
import oracle.spatial.network.lod.LogicalPath;
import oracle.spatial.network.lod.LogicalSubPath;
import oracle.spatial.network.lod.NetworkAnalyst;
import oracle.spatial.network.lod.NetworkIO;
import oracle.spatial.network.lod.NodeCostCalculator;
import oracle.spatial.network.lod.PointOnNet;

public class navigator2_main {

   private static Double initial_percentage;
   
   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   private static void setConfig(
      String network_name
   ) throws Exception {
      String xmlconfig = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>"
                       + "<LODConfigs xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "
                       + "xsi:schemaLocation=\"http://www.oracle.com/spatial/network/lod LODConfigs.xsd\" "
                       + "xmlns=\"http://www.oracle.com/spatial/network/lod\">"
                       + "<defaultLODConfig>"
                       + "<LODConfig>"
                       + "<readPartitionFromBlob>false</readPartitionFromBlob>"
                       + "<partitionBlobTranslator>oracle.spatial.network.lod.PartitionBlobTranslator11gR2</partitionBlobTranslator>"
                       + "<userDataIO>oracle.spatial.network.lod.LODUserDataIOSDO</userDataIO>"
                       + "<cachingPolicy>"
                       + "<linkLevelCachingPolicy>"
                       + "<linkLevel>1</linkLevel>"
                       + "<maxNodes>500000</maxNodes>"
                       + "<residentPartitions>-1</residentPartitions>"
                       + "<flushRule>oracle.spatial.network.lod.LRUCachingHandler</flushRule>"
                       + " </linkLevelCachingPolicy>"
                       + "</cachingPolicy>"
                       + "</LODConfig>"
                       + "</defaultLODConfig>"
                       + "<networkLODConfig>"
                       + "<networkName>" + network_name + "</networkName>"
                       + "<LODConfig>"
                       + "<readPartitionFromBlob>true</readPartitionFromBlob>"
                       + "<partitionBlobTranslator>oracle.spatial.network.lod.PartitionBlobTranslator11gR2</partitionBlobTranslator>"
                       + "<userDataIO>oracle.spatial.network.lod.LODUserDataIOSDO</userDataIO>"
                       + "<cachingPolicy>"
                       + "<linkLevelCachingPolicy>"
                       + "<linkLevel>1</linkLevel>"
                       + "<maxNodes>500000</maxNodes>"
                       + "<residentPartitions>-1</residentPartitions>"
                       + "<flushRule>oracle.spatial.network.lod.LRUCachingHandler</flushRule>"
                       + "</linkLevelCachingPolicy>"
                       + "<linkLevelCachingPolicy>"
                       + "<linkLevel>2</linkLevel>"
                       + "<maxNodes>800000</maxNodes>"
                       + "<residentPartitions>0</residentPartitions>"
                       + "<flushRule>oracle.spatial.network.lod.LRUCachingHandler</flushRule>"
                       + "</linkLevelCachingPolicy>"
                       + "</cachingPolicy>"
                       + "</LODConfig>"
                       + "</networkLODConfig>"
                       + "</LODConfigs>";
      
      InputStream stream = new ByteArrayInputStream(xmlconfig.getBytes());
      LODNetworkManager.getConfigManager().loadConfig(stream);
      
   }
   
   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   // Downstream with Tributaries
   public static int traceOutLight(
       oracle.sql.CHAR   network_name
      ,oracle.sql.NUMBER start_link_id
      ,oracle.sql.NUMBER start_percentage
      ,oracle.sql.NUMBER start_node_id
      ,oracle.sql.NUMBER cost_threshold
      
   ) throws Exception {
      
      if ( start_link_id == null || start_percentage == null || cost_threshold == null) {
         return -1;
      }
      
      LODNetworkConstraint mainstem_constraint_dn = new coastCheckConstraintDown();
      
      Connection conn = (new OracleDriver()).defaultConnection();
      
      initial_percentage = start_percentage.doubleValue();
      
      setConfig(network_name.getString());      
      
      NetworkIO reader = LODNetworkManager.getCachedNetworkIO(
          conn
         ,network_name.getString()
         ,network_name.getString()
         ,null
      );
      NetworkAnalyst analyst = LODNetworkManager.getNetworkAnalyst(reader);

      PointOnNet[] startingPoN = new PointOnNet[1];
      startingPoN[0] = new PointOnNet(
          start_link_id.longValue()
         ,start_percentage.doubleValue()
      );
      
      // Costing Changes
      LinkCostCalculator [] lccs = {
          new Calculator_Cost()
         ,new Calculator_LengthKm()
         ,new Calculator_FlowTimeDay()
      };
      analyst.setLinkCostCalculators(lccs);
      
      // Use default node cost calculator
      NodeCostCalculator [] nccs = {
          DefaultNodeCostCalculator.getNodeCostCalculator()
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
      };
      analyst.setNodeCostCalculators(nccs);
      
      LogicalLightSubPath [] subPaths = analyst.traceOutLight(
          startingPoN
         ,cost_threshold.doubleValue()
         ,1
         ,1
         ,mainstem_constraint_dn
         ,null
         ,false
      );

      int numSubPaths = subPaths.length;

      if (subPaths == null || numSubPaths == 0) {
         return -2;
      }
      
      OraclePreparedStatement opstmt_links = null;
      opstmt_links = (OraclePreparedStatement) conn.prepareStatement(
         "INSERT INTO nhdplus_navigation2.tmp_navigation_links(link_index,link_id,link_start_clip_percentage,link_end_clip_percentage,end_node_id,link_network_distancekm,link_network_flowtimeday) VALUES (?,?,?,?,?,?,?)"
      );
      opstmt_links.setExecuteBatch(2000);
      
      int numOfRowsInserted = 0;
      
      for(int i=0; i < numSubPaths; i++) {
         double path_start_percentage = subPaths[i].getStartPercentage();
         double path_end_percentage   = subPaths[i].getEndPercentage();
      
         if (path_start_percentage == 1.0 && path_end_percentage == 1.0 ) {
            
         } else {
            opstmt_links.setInt   (1,i);
            
            LogicalLightPath parent_path = subPaths[i].getReferenceLightPath();
            opstmt_links.setLong  (2,parent_path.getLastLinkId());
            
            opstmt_links.setDouble(3,path_start_percentage);
            opstmt_links.setDouble(4,path_end_percentage);
            opstmt_links.setLong  (5,parent_path.getEndNodeId());
            
            double[] path_costs = subPaths[i].getCosts();
            opstmt_links.setDouble(6,path_costs[1]);
            opstmt_links.setDouble(7,path_costs[2]);
            
            numOfRowsInserted = opstmt_links.executeUpdate(); 
         }
      }
      
      numOfRowsInserted = opstmt_links.sendBatch();
      
      opstmt_links.close();
      
      return numSubPaths;

   }
   
   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   // Downstream Mainstem
   public static int traceOutLight_mainstem(
       oracle.sql.CHAR   network_name
      ,oracle.sql.NUMBER start_link_id
      ,oracle.sql.NUMBER start_percentage
      ,oracle.sql.NUMBER start_node_id
      ,oracle.sql.NUMBER cost_threshold
   ) throws Exception {
      
      if ( start_link_id == null || start_percentage == null || cost_threshold == null) {
         return -1;
      }
      
      LODNetworkConstraint mainstem_constraint_dn = new mainstemCoastCheckConstraintDown();
      
      Connection conn = (new OracleDriver()).defaultConnection();
      
      initial_percentage = start_percentage.doubleValue();
      
      setConfig(network_name.getString());
      
      NetworkIO reader = LODNetworkManager.getCachedNetworkIO(
          conn
         ,network_name.getString()
         ,network_name.getString()
         ,null
      );
      NetworkAnalyst analyst = LODNetworkManager.getNetworkAnalyst(reader);

      PointOnNet[] startingPoN = new PointOnNet[1];
      startingPoN[0] = new PointOnNet(
          start_link_id.longValue()
         ,start_percentage.doubleValue()
      );
      
      // Costing Changes
      LinkCostCalculator [] lccs = {
          new Calculator_Cost()
         ,new Calculator_LengthKm()
         ,new Calculator_FlowTimeDay()
      };
      analyst.setLinkCostCalculators(lccs);
      
      // Use default node cost calculator
      NodeCostCalculator [] nccs = {
          DefaultNodeCostCalculator.getNodeCostCalculator()
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
      };
      analyst.setNodeCostCalculators(nccs);
      
      LogicalLightSubPath [] subPaths = analyst.traceOutLight(
          startingPoN
         ,cost_threshold.doubleValue()
         ,1
         ,1
         ,mainstem_constraint_dn
         ,null
         ,false
      );
      
      int numSubPaths = subPaths.length;

      if (subPaths == null || numSubPaths == 0) {
         return -2;
      }
      
      OraclePreparedStatement opstmt_links = null;
      opstmt_links = (OraclePreparedStatement) conn.prepareStatement(
         "INSERT INTO nhdplus_navigation2.tmp_navigation_links(link_index,link_id,link_start_clip_percentage,link_end_clip_percentage,end_node_id,link_network_distancekm,link_network_flowtimeday) VALUES (?,?,?,?,?,?,?)"
      );
      opstmt_links.setExecuteBatch(2000);
      
      int numOfRowsInserted = 0;
      
      for(int i=0; i < numSubPaths; i++) {
         double path_start_percentage = subPaths[i].getStartPercentage();
         double path_end_percentage   = subPaths[i].getEndPercentage();
      
         if (path_start_percentage == 1.0 && path_end_percentage == 1.0 ) {
            
         } else {
            opstmt_links.setInt   (1,i);
            
            LogicalLightPath parent_path = subPaths[i].getReferenceLightPath();
            opstmt_links.setLong  (2,parent_path.getLastLinkId());
            
            opstmt_links.setDouble(3,path_start_percentage);
            opstmt_links.setDouble(4,path_end_percentage);
            opstmt_links.setLong  (5,parent_path.getEndNodeId());
            
            double[] path_costs = subPaths[i].getCosts();
            opstmt_links.setDouble(6,path_costs[1]);
            opstmt_links.setDouble(7,path_costs[2]);
            
            numOfRowsInserted = opstmt_links.executeUpdate();  
         }
      }
      
      numOfRowsInserted = opstmt_links.sendBatch();
      
      opstmt_links.close();
      
      return numSubPaths;

   }
   
   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   // Upstream with Tributaries
   public static int traceInLight(
       oracle.sql.CHAR   network_name
      ,oracle.sql.NUMBER start_link_id
      ,oracle.sql.NUMBER start_percentage
      ,oracle.sql.NUMBER start_node_id
      ,oracle.sql.NUMBER cost_threshold
   ) throws Exception {
      
      if ( start_link_id == null || start_percentage == null || cost_threshold == null) {
         return -1;

      }
      
      Connection conn = (new OracleDriver()).defaultConnection();
      
      initial_percentage = start_percentage.doubleValue();
      
      setConfig(network_name.getString());
      
      NetworkIO reader = LODNetworkManager.getCachedNetworkIO(
          conn
         ,network_name.getString()
         ,network_name.getString()
         ,null
      );
      NetworkAnalyst analyst = LODNetworkManager.getNetworkAnalyst(reader);

      long   num_start_link_id    = start_link_id.longValue();
      double num_start_percentage = start_percentage.doubleValue();
      long   num_start_node_id    = start_node_id.longValue();
      
      PointOnNet[] startingPoN = new PointOnNet[1];
      
      if (num_start_percentage == 0.0) {
         startingPoN[0] = new PointOnNet(
             num_start_node_id
         );
         
      } else {
         startingPoN[0] = new PointOnNet(
             num_start_link_id
            ,num_start_percentage
         );  
      }
      
      // Costing Changes
      LinkCostCalculator [] lccs = {
          new Calculator_Cost()
         ,new Calculator_LengthKm()
         ,new Calculator_FlowTimeDay()
      };
      analyst.setLinkCostCalculators(lccs);
      
      // Use default node cost calculator
      NodeCostCalculator [] nccs = {
          DefaultNodeCostCalculator.getNodeCostCalculator()
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
      };
      analyst.setNodeCostCalculators(nccs); 

      LogicalLightSubPath [] subPaths = analyst.traceInLight(
          startingPoN
         ,cost_threshold.doubleValue()
         ,1
         ,1
         ,null
         ,null
         ,false
      );

      int numOfRowsInserted = 0;
      int numSubPaths = subPaths.length;      
      if (subPaths == null || numSubPaths == 0) {
         return -2;
      }
      
      OraclePreparedStatement opstmt_links = null;
      opstmt_links = (OraclePreparedStatement) conn.prepareStatement(
         "INSERT INTO nhdplus_navigation2.tmp_navigation_links(link_index,link_id,link_start_clip_percentage,link_end_clip_percentage,end_node_id,link_network_distancekm,link_network_flowtimeday) VALUES (?,?,?,?,?,?,?)"
      );
      opstmt_links.setExecuteBatch(2000);
      
      for(int i=0; i < numSubPaths; i++) {
         LogicalLightPath parent_path = subPaths[i].getReferenceLightPath();
         double path_start_percentage = subPaths[i].getStartPercentage();
         double path_end_percentage   = subPaths[i].getEndPercentage();
         long   path_first_link_id    = parent_path.getFirstLinkId();
         long   path_start_node_id    = parent_path.getStartNodeId();

         if (path_start_percentage == 0.0 && path_end_percentage == 0.0 ) {
            // skip insert

         } else if (num_start_percentage != 1.0 && path_first_link_id == num_start_link_id && path_end_percentage == 1.0 && path_start_percentage == 0.0) {
            // skip insert

         } else {
            
            opstmt_links.setInt   (1,i);
            opstmt_links.setLong  (2,path_first_link_id);
            opstmt_links.setDouble(3,path_end_percentage);
            opstmt_links.setDouble(4,path_start_percentage);
            opstmt_links.setLong  (5,path_start_node_id);
            double[] path_costs = subPaths[i].getCosts();
            opstmt_links.setDouble(6,path_costs[1]);
            opstmt_links.setDouble(7,path_costs[2]);
            
            numOfRowsInserted = opstmt_links.executeUpdate();
         }
      }

      numOfRowsInserted = opstmt_links.sendBatch();

      opstmt_links.close();

      return numSubPaths;
      
   }

   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   // Upstream Mainstem
   public static int traceInLight_mainstem(
       oracle.sql.CHAR   network_name
      ,oracle.sql.NUMBER start_link_id
      ,oracle.sql.NUMBER start_percentage
      ,oracle.sql.NUMBER start_node_id
      ,oracle.sql.NUMBER cost_threshold
      
   ) throws Exception {
      
      if ( start_link_id == null || start_percentage == null || cost_threshold == null) {
         //System.out.println(">>-1 " + start_percentage);
         return -1;
      }
      
      LODNetworkConstraint mainstem_constraint_up = new mainstemConstraintUp();
      
      Connection conn = (new OracleDriver()).defaultConnection();
      
      initial_percentage = start_percentage.doubleValue();
      
      setConfig(network_name.getString());
      
      NetworkIO reader = LODNetworkManager.getCachedNetworkIO(
          conn
         ,network_name.getString()
         ,network_name.getString()
         ,null
      );
      NetworkAnalyst analyst = LODNetworkManager.getNetworkAnalyst(reader);

      long   num_start_link_id    = start_link_id.longValue();
      double num_start_percentage = start_percentage.doubleValue();
      long   num_start_node_id    = start_node_id.longValue();
      
      PointOnNet[] startingPoN = new PointOnNet[1];
      if (num_start_percentage == 0.0) {
         startingPoN[0] = new PointOnNet(
             num_start_node_id
         );
         
      } else {
         startingPoN[0] = new PointOnNet(
             num_start_link_id
            ,num_start_percentage
         );
         
      }
      
      // Costing Changes
      LinkCostCalculator [] lccs = {
          new Calculator_Cost()
         ,new Calculator_LengthKm()
         ,new Calculator_FlowTimeDay()
      };
      analyst.setLinkCostCalculators(lccs);
      
      // Use default node cost calculator
      NodeCostCalculator [] nccs = {
          DefaultNodeCostCalculator.getNodeCostCalculator()
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
      };
      analyst.setNodeCostCalculators(nccs); 
      
      LogicalLightSubPath [] subPaths = analyst.traceInLight(
          startingPoN
         ,cost_threshold.doubleValue()
         ,1
         ,1
         ,mainstem_constraint_up
         ,null
         ,false
      );
      
      int numOfRowsInserted = 0;
      int numSubPaths = subPaths.length;      
      if (subPaths == null || numSubPaths == 0) {
         //System.out.println(">>-2 " + numSubPaths);
         return -2;
      }
      
      OraclePreparedStatement opstmt_links = null;
      opstmt_links = (OraclePreparedStatement) conn.prepareStatement(
         "INSERT INTO nhdplus_navigation2.tmp_navigation_links(link_index,link_id,link_start_clip_percentage,link_end_clip_percentage,end_node_id,link_network_distancekm,link_network_flowtimeday) VALUES (?,?,?,?,?,?,?)"
      );
      opstmt_links.setExecuteBatch(2000);
      
      for(int i=0; i < numSubPaths; i++) {
         LogicalLightPath parent_path = subPaths[i].getReferenceLightPath();
         double path_start_percentage = subPaths[i].getStartPercentage();
         double path_end_percentage   = subPaths[i].getEndPercentage();
         long   path_first_link_id    = parent_path.getFirstLinkId();
         long   path_start_node_id    = parent_path.getStartNodeId();

         if (path_start_percentage == 0.0 && path_end_percentage == 0.0 ) {
            // skip insert

         } else if (num_start_percentage != 1.0 && path_first_link_id == num_start_link_id && path_end_percentage == 1.0 && path_start_percentage == 0.0) {
            // skip insert

         } else {
            
            opstmt_links.setInt   (1,i);
            opstmt_links.setLong  (2,path_first_link_id);
            opstmt_links.setDouble(3,path_end_percentage);
            opstmt_links.setDouble(4,path_start_percentage);
            opstmt_links.setLong  (5,path_start_node_id);
            double[] path_costs = subPaths[i].getCosts();
            //System.out.println(i + " " + path_costs[1]);
            opstmt_links.setDouble(6,path_costs[1]);
            opstmt_links.setDouble(7,path_costs[2]);
            
            numOfRowsInserted = opstmt_links.executeUpdate();
         }
      }

      numOfRowsInserted = opstmt_links.sendBatch();

      opstmt_links.close();

      return numSubPaths;

   }

   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   private static class mainstemConstraintUp implements LODNetworkConstraint {

      private Map<Long, boolean[]> partiallyExpandedNodes =
         new HashMap<Long, boolean[]>();

      public int getNumberOfUserObjects() { 
         return 0; 
      }
      
      public int[] getUserDataCategories() {
         return null; 
      }
      
      public boolean isCurrentNodePartiallyExpanded(LODAnalysisInfo info) { 
         long currNodeId = info.getCurrentNode().getId();
         return partiallyExpandedNodes.containsKey(currNodeId);
      }
      
      public boolean isNextNodePartiallyExpanded(LODAnalysisInfo info) { 
         long nextNodeId = info.getNextNode().getId();
         return partiallyExpandedNodes.containsKey(nextNodeId);
      }
      
      public boolean isSatisfied(LODAnalysisInfo info) {
         boolean isTurnValid = false;
         
         LogicalNetLink currentLink = info.getCurrentLink();
         LogicalNetLink nextLink    = info.getNextLink();
         
         if ( currentLink == null ) { 
            return true;
            
         } else {
            long hydrosequence = nextLink.getId();
            
            CategorizedUserData cud = currentLink.getCategorizedUserData();
            // 0 is divergence
            // 1 is downhydrosequence
            // 2 is fcode
            // 3 is flowtimeday
            // 4 is lengthkm
            // 5 is uphydrosequence
            Double dfoo = (Double) cud.getUserData(0).get(5);
            Long ifoo = dfoo.longValue();
            long uphydrosequence = ifoo;
            //System.out.println(">> " + uphydrosequence);
            
            if ( uphydrosequence == hydrosequence ) {
               isTurnValid = true; 
               
            }

         } 

         //update partiallyExpandedNodes
         LogicalNetNode currNode   = info.getCurrentNode();
         LogicalNetLink[] outLinks = currNode.getOutLinks(true);
         boolean[] isOutLinksExpanded = partiallyExpandedNodes.get(currNode.getId());
            
         if (isOutLinksExpanded == null) {
            isOutLinksExpanded = new boolean[currNode.getNumberOfOutLinks()];
            partiallyExpandedNodes.put(currNode.getId(), isOutLinksExpanded);
         }
           
         boolean isFullyExpanded = true;
         for (int i = 0; i < outLinks.length; i++) {
            if (outLinks[i].getId() == nextLink.getId()) {
               if (isTurnValid) {
                  isOutLinksExpanded[i] = true;
               }
             }
                
             isFullyExpanded = isFullyExpanded && isOutLinksExpanded[i];
         }
            
         if (isFullyExpanded) {
            partiallyExpandedNodes.remove(currNode.getId());
         }
         
         return isTurnValid;
          
      }
      
      public void reset(){
         partiallyExpandedNodes.clear();
      } 
      
      public void setNetworkAnalyst(NetworkAnalyst analyst){}
      
   }
   
   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   private static class mainstemCoastCheckConstraintDown implements LODNetworkConstraint {

      private Map<Long, boolean[]> partiallyExpandedNodes =
         new HashMap<Long, boolean[]>();

      public int getNumberOfUserObjects() { 
         return 0; 
      }
      
      public int[] getUserDataCategories() {
         return null; 
      }
      
      public boolean isCurrentNodePartiallyExpanded(LODAnalysisInfo info) { 
         long currNodeId = info.getCurrentNode().getId();
         return partiallyExpandedNodes.containsKey(currNodeId);
      }
      
      public boolean isNextNodePartiallyExpanded(LODAnalysisInfo info) { 
         long nextNodeId = info.getNextNode().getId();
         return partiallyExpandedNodes.containsKey(nextNodeId);
      }
      
      public boolean isSatisfied(LODAnalysisInfo info) {
         boolean isTurnValid = false;
         
         LogicalNetLink currentLink = info.getCurrentLink();
         LogicalNetLink nextLink    = info.getNextLink();
         
         if ( currentLink == null ) { 
            return true;
            
         } else {
            long hydrosequence = nextLink.getId();
            
            CategorizedUserData curr_cud = currentLink.getCategorizedUserData();
            CategorizedUserData next_cud = nextLink.getCategorizedUserData();
            
            // 0 is divergence
            // 1 is downhydrosequence
            // 2 is fcode
            // 3 is flowtimeday
            // 4 is lengthkm
            // 5 is uphydrosequence           
            Double dfoo = (Double) curr_cud.getUserData(0).get(1);
            Long ifoo = dfoo.longValue();
            long downhydrosequence = ifoo;
            
            int currentfcode = (Integer) curr_cud.getUserData(0).get(2);
            int nextfcode    = (Integer) next_cud.getUserData(0).get(2);
            
            if (currentfcode != 56600 && nextfcode == 56600 ) {
               // deny a turn onto coast when going downstream from surface water
               isTurnValid = false;
               
            } else {
               if ( downhydrosequence == hydrosequence ) {
                  isTurnValid = true; 
               }  
            }
         } 

         //update partiallyExpandedNodes
         LogicalNetNode currNode   = info.getCurrentNode();
         LogicalNetLink[] outLinks = currNode.getOutLinks(true);
         boolean[] isOutLinksExpanded = partiallyExpandedNodes.get(currNode.getId());
            
         if (isOutLinksExpanded == null) {
            isOutLinksExpanded = new boolean[currNode.getNumberOfOutLinks()];
            partiallyExpandedNodes.put(currNode.getId(), isOutLinksExpanded);
         }
           
         boolean isFullyExpanded = true;
         for (int i = 0; i < outLinks.length; i++) {
            if (outLinks[i].getId() == nextLink.getId()) {
               if (isTurnValid) {
                  isOutLinksExpanded[i] = true;
               }
             }
                
             isFullyExpanded = isFullyExpanded && isOutLinksExpanded[i];
         }
            
         if (isFullyExpanded) {
            partiallyExpandedNodes.remove(currNode.getId());
         }
         
         return isTurnValid;
          
      }
      
      public void reset(){
         partiallyExpandedNodes.clear();
      } 
      
      public void setNetworkAnalyst(NetworkAnalyst analyst){}
      
   }
   
   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   private static class coastCheckConstraintDown implements LODNetworkConstraint {

      private Map<Long, boolean[]> partiallyExpandedNodes =
         new HashMap<Long, boolean[]>();

      public int getNumberOfUserObjects() { 
         return 0; 
      }
      
      public int[] getUserDataCategories() {
         return null; 
      }
      
      public boolean isCurrentNodePartiallyExpanded(LODAnalysisInfo info) { 
         long currNodeId = info.getCurrentNode().getId();
         return partiallyExpandedNodes.containsKey(currNodeId);
      }
      
      public boolean isNextNodePartiallyExpanded(LODAnalysisInfo info) { 
         long nextNodeId = info.getNextNode().getId();
         return partiallyExpandedNodes.containsKey(nextNodeId);
      }
      
      public boolean isSatisfied(LODAnalysisInfo info) {
         boolean isTurnValid = false;
         
         LogicalNetLink currentLink = info.getCurrentLink();
         LogicalNetLink nextLink    = info.getNextLink();
         
         if ( currentLink == null ) { 
            return true;
            
         } else {
            CategorizedUserData curr_cud = currentLink.getCategorizedUserData();
            CategorizedUserData next_cud = nextLink.getCategorizedUserData();

            // 0 is divergence
            // 1 is downhydrosequence
            // 2 is fcode
            // 3 is flowtimeday
            // 4 is lengthkm
            // 5 is uphydrosequence
            int currentfcode = (Integer) curr_cud.getUserData(0).get(2);
            int nextfcode    = (Integer) next_cud.getUserData(0).get(2);
            
            if (currentfcode != 56600 && nextfcode == 56600 ) {
               // deny a turn onto coast when going downstream from surface water
               isTurnValid = false;
               
            } else {
               isTurnValid = true; 
                  
            }

         } 

         //update partiallyExpandedNodes
         LogicalNetNode currNode   = info.getCurrentNode();
         LogicalNetLink[] outLinks = currNode.getOutLinks(true);
         boolean[] isOutLinksExpanded = partiallyExpandedNodes.get(currNode.getId());
            
         if (isOutLinksExpanded == null) {
            isOutLinksExpanded = new boolean[currNode.getNumberOfOutLinks()];
            partiallyExpandedNodes.put(currNode.getId(), isOutLinksExpanded);
         }
           
         boolean isFullyExpanded = true;
         for (int i = 0; i < outLinks.length; i++) {
            if (outLinks[i].getId() == nextLink.getId()) {
               if (isTurnValid) {
                  isOutLinksExpanded[i] = true;
               }
             }
                
             isFullyExpanded = isFullyExpanded && isOutLinksExpanded[i];
         }
            
         if (isFullyExpanded) {
            partiallyExpandedNodes.remove(currNode.getId());
         }
         
         return isTurnValid;
          
      }
      
      public void reset(){
         partiallyExpandedNodes.clear();
      } 
      
      public void setNetworkAnalyst(NetworkAnalyst analyst){}
      
   }
   
   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   public static int shortestPath(
       oracle.sql.CHAR   network_name
      ,oracle.sql.NUMBER start_link_id
      ,oracle.sql.NUMBER start_percentage
      ,oracle.sql.NUMBER start_node_id
      ,oracle.sql.NUMBER stop_link_id
      ,oracle.sql.NUMBER stop_percentage
      
   ) throws Exception {
      
      if ( start_link_id == null || start_percentage == null) {
         return -1;
      }
      
      setConfig(network_name.getString());
      
      Connection conn = (new OracleDriver()).defaultConnection();
      NetworkIO reader = LODNetworkManager.getCachedNetworkIO(
          conn
         ,network_name.getString()
         ,network_name.getString()
         ,null
      );
      NetworkAnalyst analyst = LODNetworkManager.getNetworkAnalyst(reader);

      PointOnNet[] startingPoN = new PointOnNet[1];
      startingPoN[0] = new PointOnNet(
          start_link_id.longValue()
         ,start_percentage.doubleValue()
      );
      
      PointOnNet[] stoppingPoN = new PointOnNet[1];
      stoppingPoN[0] = new PointOnNet(
          stop_link_id.longValue()
         ,stop_percentage.doubleValue()
      );
      
      // Costing Changes
      LinkCostCalculator [] lccs = {
          new Calculator_CostPP() 
         ,new Calculator_LengthKm()
         ,new Calculator_FlowTimeDay() 
      };
      analyst.setLinkCostCalculators(lccs);
      
      // Use default node cost calculator
      NodeCostCalculator [] nccs = {
          DefaultNodeCostCalculator.getNodeCostCalculator()
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
         ,DefaultNodeCostCalculator.getNodeCostCalculator() 
      };
      analyst.setNodeCostCalculators(nccs); 
      
      LogicalSubPath subpath = analyst.shortestPathDijkstra(
          startingPoN
         ,stoppingPoN
         ,1
         ,null
      );
      
      if (subpath == null) {
         return -2;
      }
      
      LogicalPath path = subpath.getReferencePath();
      int    sp_start_link_idx   = subpath.getStartLinkIndex();
      int    sp_end_link_idx     = subpath.getEndLinkIndex();
      double sp_start_percentage = subpath.getStartPercentage();
      double sp_end_percentage   = subpath.getEndPercentage();
      double dbltemp             = 0;
      
      long [] nodes = path.getNodeIds();
      int node_count = nodes.length;
      
      int numOfRowsInserted = 0;
      
      if ( node_count == 2 ) {
         OraclePreparedStatement opstmt_links = null;
         opstmt_links = (OraclePreparedStatement) conn.prepareStatement(
            "INSERT INTO nhdplus_navigation2.tmp_navigation_links(link_index,link_id,link_start_clip_percentage,link_end_clip_percentage,link_network_distancekm,link_network_flowtimeday) VALUES (?,?,?,?,?,?)"
         );
         opstmt_links.setExecuteBatch(2000);
         
         opstmt_links.setInt   (1,1);
         opstmt_links.setLong  (2,path.getFirstLinkId());
         opstmt_links.setDouble(3,sp_start_percentage);
         opstmt_links.setDouble(4,sp_end_percentage);
         opstmt_links.setDouble(5,subpath.getCosts()[1]);
         opstmt_links.setDouble(6,subpath.getCosts()[2]);
            
         numOfRowsInserted = opstmt_links.executeUpdate();
         numOfRowsInserted = opstmt_links.sendBatch();

      } else {
         OraclePreparedStatement opstmt_nodes = null;
         opstmt_nodes = (OraclePreparedStatement) conn.prepareStatement(
            "INSERT INTO nhdplus_navigation2.tmp_navigation_nodes(node_index,node_id,end_cost,end_network_distancekm,end_network_flowtimeday) VALUES (?,?,?,?,?)"
         );
         opstmt_nodes.setExecuteBatch(2000);
         
         for(int i=0; i < node_count; i++) {
            // node_index
            opstmt_nodes.setInt(1,i);
            
            // node_id
            opstmt_nodes.setLong(2,nodes[i]);
            
            // end_cost
            opstmt_nodes.setDouble(3,subpath.getCostsToNode(i)[0]);
            
            // end_network_distancekm cost
            opstmt_nodes.setDouble(4,subpath.getCostsToNode(i)[1]);

            // end_network_flowtimeday cost
            opstmt_nodes.setDouble(5,subpath.getCostsToNode(i)[2]);
            
            numOfRowsInserted = opstmt_nodes.executeUpdate();
            
         }
         numOfRowsInserted = opstmt_nodes.sendBatch();      
         nodes = null;
         
         long [] links = path.getLinkIds();
         int link_count = links.length;
         
         OraclePreparedStatement opstmt_links = null;
         opstmt_links = (OraclePreparedStatement) conn.prepareStatement(
            "INSERT INTO nhdplus_navigation2.tmp_navigation_links(link_index,link_id,link_start_clip_percentage,link_end_clip_percentage) VALUES (?,?,?,?)"
         );
         opstmt_links.setExecuteBatch(2000);

         for(int i=0; i < link_count; i++) {
            opstmt_links.setInt   (1,i);
            opstmt_links.setLong  (2,links[i]);
            
            if ( i == sp_start_link_idx ) {
               dbltemp = sp_start_percentage;
            } else {
               dbltemp = 0;
            }
            opstmt_links.setDouble(3,dbltemp);
            
            if (i == sp_end_link_idx ) {
               dbltemp = sp_end_percentage;
            } else {
               dbltemp = 1.00;
            }
            opstmt_links.setDouble(4,dbltemp);
            
            numOfRowsInserted = opstmt_links.executeUpdate();
         }
         
         numOfRowsInserted = opstmt_links.sendBatch();
         
         opstmt_nodes.close();
         opstmt_links.close();
         
      }
      
      return numOfRowsInserted;

   }
   
   /////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////
   private static class Calculator_Cost implements LinkCostCalculator {  
      
      public double getLinkCost(LODAnalysisInfo analysisInfo) {
         
         LogicalLink nextLink    = analysisInfo.getNextLink(); 
         return nextLink.getCost();
         
      }
      
      public int getNumberOfUserObjects() { return 0 ; }

      public int[] getUserDataCategories() {
         return null;
      }
      
   }
   
   private static class Calculator_CostPP implements LinkCostCalculator {  
      
      public double getLinkCost(LODAnalysisInfo analysisInfo) {
         
         LogicalLink currentLink = analysisInfo.getCurrentLink();
         LogicalLink nextLink    = analysisInfo.getNextLink(); 
          
         double linkCost = nextLink.getCost();
         
         if (analysisInfo.getCurrentLink() != null) {
            
            long hydrosequence = nextLink.getId();
            
            CategorizedUserData cud = currentLink.getCategorizedUserData();
            
            // 0 is divergence
            // 1 is downhydrosequence
            // 2 is fcode
            // 3 is flowtimeday
            // 4 is lengthkm
            // 5 is uphydrosequence
            Double dfoo = (Double) cud.getUserData(0).get(1);
            Long ifoo = dfoo.longValue();
            long downhydrosequence = ifoo;
            
            if ( downhydrosequence != hydrosequence ) {
               linkCost = linkCost * 100;
            }
         } 
         
         return linkCost;
         
      }
      
      public int getNumberOfUserObjects() { return 0 ; }

      public int[] getUserDataCategories() {
         return null;
      }
      
   }
   
   private static class Calculator_LengthKm implements LinkCostCalculator {  
      
      public double getLinkCost(LODAnalysisInfo analysisInfo) {
         
         LogicalLink nextLink         = analysisInfo.getNextLink();
         CategorizedUserData next_cud = nextLink.getCategorizedUserData();
         
         // 0 is divergence
         // 1 is downhydrosequence
         // 2 is fcode
         // 3 is flowtimeday
         // 4 is lengthkm
         // 5 is uphydrosequence
         double linkCost = (Double) next_cud.getUserData(0).get(4);
          
         return linkCost;
         
      }
      
      public int getNumberOfUserObjects() { return 0 ; }

      public int[] getUserDataCategories() {
         return null;
      }
      
   }
   
   private static class Calculator_FlowTimeDay implements LinkCostCalculator {  
      
      public double getLinkCost(LODAnalysisInfo analysisInfo) {
         
         LogicalLink currLink = analysisInfo.getCurrentLink();
         LogicalLink nextLink = analysisInfo.getNextLink();
         
         CategorizedUserData next_cud = nextLink.getCategorizedUserData();
         
         // 0 is divergence
         // 1 is downhydrosequence
         // 2 is fcode
         // 3 is flowtimeday
         // 4 is lengthkm
         // 5 is uphydrosequence
         
         double nextFlowTimeDayCost = (Double) next_cud.getUserData(0).get(3);
         
         if ( nextFlowTimeDayCost < 0 ) {
            return -10000000;
         }
          
         return nextFlowTimeDayCost;
         
      }
      
      public int getNumberOfUserObjects() { return 0 ; }

      public int[] getUserDataCategories() {
         return null;
      }
      
   }
   
}
/

GRANT EXECUTE ON nhdplus_navigation2."navigator2_main" TO public;

